use anyhow::{Context, Result};
use inquire::Confirm;
use chrono::Local;
use serde::Serialize;
use std::path::Path;
use tracing::info;

use crate::config::Config;
use crate::git;

// ─── Output types ─────────────────────────────────────────────────────────────

#[derive(Serialize)]
pub struct ClosePayload {
    pub session_word_count: u32,
    pub total_word_count: u32,
    pub target_length: u32,
    pub completion_ready: bool,
    pub status: &'static str,
}

#[derive(Serialize)]
pub struct CompletePayload {
    pub status: &'static str,
    pub total_word_count: u32,
}

// ─── Helpers ──────────────────────────────────────────────────────────────────

const FULL_BOOK_HEADER: &str =
    "<!-- ⚠ INK-GATEWAY:MANAGED — Do not edit this file directly.\n\
     Human edits belong in Review/current.md.\n\
     Validated content is appended automatically after each session.\n\
     Use `ink-cli rollback` to undo the last session. -->";

/// Find the byte position of the first author instruction comment `<!-- INK: ` in `content`.
/// Deliberately does NOT match engine markers `<!-- INK:NEW:` or `<!-- INK:REWORKED:`.
fn find_first_ink_instruction(content: &str) -> Option<usize> {
    let mut search_from = 0;
    while let Some(rel) = content[search_from..].find("<!-- INK:") {
        let abs = search_from + rel;
        // Check for the space that distinguishes author instructions from engine markers
        let after = &content[abs + 9..]; // skip "<!-- INK:"
        if after.starts_with(' ') {
            return Some(abs);
        }
        search_from = abs + 9;
    }
    None
}

/// Count prose words, ignoring HTML comment lines.
fn count_prose_words(content: &str) -> u32 {
    content
        .lines()
        .filter(|l| !l.trim_start().starts_with("<!--"))
        .flat_map(|l| l.split_whitespace())
        .count() as u32
}

/// Insert `<!-- PAGE N -->` markers into `new_content` at paragraph boundaries
/// closest to each `words_per_page` boundary, given that the book already has
/// `start_word_count` prose words before this content.
fn insert_pagination(start_word_count: u32, new_content: &str, words_per_page: u32) -> String {
    if words_per_page == 0 {
        return new_content.to_string();
    }

    let mut chunks: Vec<String> = Vec::new();
    let mut cumulative = start_word_count;
    // First boundary we haven't yet marked
    let mut next_mark = ((start_word_count / words_per_page) + 1) * words_per_page;

    for para in new_content.split("\n\n") {
        let para = para.trim();
        if para.is_empty() {
            continue;
        }
        let para_words = para.split_whitespace().count() as u32;

        // Insert marker(s) for every boundary this paragraph crosses or lands on
        while cumulative < next_mark && cumulative + para_words >= next_mark {
            let page_num = next_mark / words_per_page + 1;
            chunks.push(format!("<!-- PAGE {} -->", page_num));
            next_mark += words_per_page;
        }

        chunks.push(para.to_string());
        cumulative += para_words;
    }

    chunks.join("\n\n")
}

// ─── session-close ─────────────────────────────────────────────────────────────

pub fn close_session(
    repo: &Path,
    prose: &str,
    summary: Option<&str>,
    human_edits: &[String],
) -> Result<ClosePayload> {
    let lock_path = repo.join(".ink-running");

    // Guard: lock must exist
    if !lock_path.exists() {
        let error = serde_json::json!({"error": "no active session", "status": "error"});
        println!("{}", serde_json::to_string_pretty(&error).unwrap());
        std::process::exit(1);
    }

    let config = Config::load(repo)?;
    let now = Local::now();
    let session_word_count = prose.split_whitespace().count() as u32;

    // ── Step 1: Read old current.md, split at first INK instruction ──────────
    info!("Reading Review/current.md to extract validated content");
    let review_dir = repo.join("Review");
    let current_md_path = review_dir.join("current.md");

    let old_current = if current_md_path.exists() {
        std::fs::read_to_string(&current_md_path)
            .with_context(|| "Failed to read Review/current.md")?
    } else {
        String::new()
    };

    // Everything before the first author INK instruction is validated prose
    let validated = match find_first_ink_instruction(&old_current) {
        Some(pos) => old_current[..pos].trim_end().to_string(),
        None => old_current.trim_end().to_string(), // no instructions → all is validated
    };

    // ── Step 2: Append validated content to Full_Book.md ────────────────────
    info!("Appending validated content to Full_Book.md");
    let book_dir = repo.join("Current version");
    std::fs::create_dir_all(&book_dir)
        .with_context(|| "Failed to create 'Current version/'")?;
    let book_path = book_dir.join("Full_Book.md");

    let total_word_count = if !validated.trim().is_empty() {
        let mut book = if book_path.exists() {
            std::fs::read_to_string(&book_path)
                .with_context(|| "Failed to read Full_Book.md")?
        } else {
            format!("{}\n", FULL_BOOK_HEADER)
        };

        let existing_prose_words = count_prose_words(&book);
        let paginated = insert_pagination(existing_prose_words, validated.trim(), config.words_per_page);

        if !book.ends_with('\n') {
            book.push('\n');
        }
        book.push('\n');
        book.push_str(&paginated);
        if !book.ends_with('\n') {
            book.push('\n');
        }

        let total = count_prose_words(&book);
        std::fs::write(&book_path, &book)
            .with_context(|| "Failed to write Full_Book.md")?;
        total
    } else {
        // Nothing validated this session — just report current word count
        if book_path.exists() {
            let content = std::fs::read_to_string(&book_path)
                .with_context(|| "Failed to read Full_Book.md")?;
            count_prose_words(&content)
        } else {
            0
        }
    };

    // ── Step 3: Write new current.md = engine prose (REWORKED + NEW blocks) ──
    info!("Writing new Review/current.md");
    std::fs::create_dir_all(&review_dir)
        .with_context(|| "Failed to create Review/")?;
    std::fs::write(&current_md_path, prose)
        .with_context(|| "Failed to write Review/current.md")?;

    // ── Step 4: Append to Summary.md ─────────────────────────────────────────
    info!("Appending to Summary.md");
    let summary_path = repo.join("Global Material").join("Summary.md");
    let delta_text = summary
        .map(|s| s.to_string())
        .unwrap_or_else(|| {
            format!(
                "Session {} — {} words written.",
                now.format("%Y-%m-%d %H:%M"),
                session_word_count
            )
        });
    let delta = format!("\n\n{}", delta_text.trim());
    let mut existing_summary = if summary_path.exists() {
        std::fs::read_to_string(&summary_path)
            .with_context(|| "Failed to read Summary.md")?
    } else {
        String::new()
    };
    existing_summary.push_str(&delta);
    std::fs::write(&summary_path, &existing_summary)
        .with_context(|| "Failed to write Summary.md")?;

    // ── Step 5: Write Changelog entry ────────────────────────────────────────
    info!("Writing changelog entry");
    let changelog_dir = repo.join("Changelog");
    std::fs::create_dir_all(&changelog_dir)
        .with_context(|| "Failed to create Changelog/")?;
    let changelog_filename = format!("{}.md", now.format("%Y-%m-%d-%H-%M"));
    let changelog_path = changelog_dir.join(&changelog_filename);

    let mut changelog = format!(
        "# Session {}\n\n**Words written:** {}\n",
        now.format("%Y-%m-%d %H:%M"),
        session_word_count
    );
    if !human_edits.is_empty() {
        changelog.push_str("\n**Human edits:**\n");
        for edit in human_edits {
            changelog.push_str(&format!("- {}\n", edit));
        }
    }
    if let Some(s) = summary {
        changelog.push_str(&format!("\n**Summary:**\n{}\n", s.trim()));
    }

    std::fs::write(&changelog_path, &changelog)
        .with_context(|| format!("Failed to write {}", changelog_path.display()))?;

    // ── Step 6: Commit and push ───────────────────────────────────────────────
    info!("Committing session on draft branch");
    git::run_git(repo, &["rm", "-f", ".ink-running"])
        .with_context(|| "Failed to git rm .ink-running")?;
    git::run_git(repo, &["add", "-A"])
        .with_context(|| "Failed to git add session files")?;
    git::run_git(repo, &["commit", "-m", "session: write prose"])
        .with_context(|| "Failed to commit session files")?;
    git::run_git(repo, &["push", "origin", "draft"])
        .with_context(|| "Failed to push draft")?;

    info!("Fast-forward merging draft into main and pushing");
    git::run_git(repo, &["checkout", "main"])
        .with_context(|| "Failed to checkout main")?;
    git::run_git(repo, &["merge", "--ff-only", "draft"])
        .with_context(|| "Failed to fast-forward merge draft into main")?;
    git::run_git(repo, &["push", "origin", "main"])
        .with_context(|| "Failed to push main")?;

    let completion_ready = total_word_count >= (config.target_length as f64 * 0.9) as u32;

    Ok(ClosePayload {
        session_word_count,
        total_word_count,
        target_length: config.target_length,
        completion_ready,
        status: "closed",
    })
}

// ─── complete ─────────────────────────────────────────────────────────────────

pub fn complete_session(repo: &Path) -> Result<CompletePayload> {
    let complete_path = repo.join("COMPLETE");

    // Guard: COMPLETE must not already exist
    if complete_path.exists() {
        let error = serde_json::json!({"error": "book already complete", "status": "error"});
        println!("{}", serde_json::to_string_pretty(&error).unwrap());
        std::process::exit(1);
    }

    // Ensure we're on main
    git::run_git(repo, &["checkout", "main"])
        .with_context(|| "Failed to checkout main for complete")?;

    // Write COMPLETE marker
    info!("Writing COMPLETE marker");
    std::fs::write(&complete_path, "")
        .with_context(|| "Failed to write COMPLETE")?;

    // Remove stale .ink-running if still present
    let lock_path = repo.join(".ink-running");
    if lock_path.exists() {
        git::run_git(repo, &["rm", "-f", ".ink-running"])
            .with_context(|| "Failed to git rm .ink-running")?;
    }

    // Count total prose words
    let book_path = repo.join("Current version").join("Full_Book.md");
    let total_word_count = if book_path.exists() {
        let content = std::fs::read_to_string(&book_path)
            .with_context(|| "Failed to read Full_Book.md for word count")?;
        count_prose_words(&content)
    } else {
        0
    };

    // Commit and push
    git::run_git(repo, &["add", "-A"])
        .with_context(|| "Failed to git add COMPLETE")?;
    git::run_git(repo, &["commit", "-m", "book: complete"])
        .with_context(|| "Failed to commit completion")?;
    git::run_git(repo, &["push", "origin", "main"])
        .with_context(|| "Failed to push completion")?;

    Ok(CompletePayload {
        status: "complete",
        total_word_count,
    })
}

// ─── rollback ─────────────────────────────────────────────────────────────────

/// Revert main (and draft) to the snapshot tag created at the start of the
/// last writing session, undoing all prose generated in that session.
pub fn rollback_session(repo_path: &Path) -> Result<()> {
    // Collect all ink-* tags and sort reverse-chronologically.
    let raw = git::run_git(repo_path, &["tag", "-l", "ink-*"])?;
    let mut tags: Vec<&str> = raw
        .lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty())
        .collect();
    tags.sort_by(|a, b| b.cmp(a));

    let target = tags
        .first()
        .ok_or_else(|| anyhow::anyhow!("No ink-* snapshot tags found — nothing to roll back"))?;

    println!("\n  Rollback target : {}", target);
    if let Some(prev) = tags.get(1) {
        println!("  Previous snapshot: {}", prev);
    }
    println!();
    println!("  This will permanently remove the last session's prose,");
    println!("  Summary.md entry, and Changelog entry, then force-push.");

    let confirmed = Confirm::new("Confirm rollback?")
        .with_default(false)
        .prompt()
        .with_context(|| "Failed to read confirmation")?;

    if !confirmed {
        println!("  Rollback cancelled.");
        return Ok(());
    }

    // Ensure we're on main before resetting
    git::run_git(repo_path, &["checkout", "main"])
        .with_context(|| "Failed to checkout main")?;

    // Hard reset main to the snapshot tag
    git::run_git(repo_path, &["reset", "--hard", target])
        .with_context(|| format!("Failed to reset to {}", target))?;

    // Force-push main
    git::run_git(repo_path, &["push", "--force", "origin", "main"])
        .with_context(|| "Failed to force-push main")?;

    // Reset draft to main if it exists
    if git::run_git(repo_path, &["show-ref", "--verify", "refs/heads/draft"]).is_ok() {
        git::run_git(repo_path, &["branch", "-f", "draft", "main"])
            .with_context(|| "Failed to reset draft branch")?;
        git::run_git(repo_path, &["push", "--force", "origin", "draft"])
            .with_context(|| "Failed to force-push draft")?;
    }

    println!("\n  Rolled back to {}.", target);
    println!("  The last session's prose has been removed.");
    println!("  Run the next session normally when ready.\n");

    Ok(())
}
