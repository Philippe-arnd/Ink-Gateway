use anyhow::{anyhow, Context, Result};
use chrono::Local;
use inquire::Confirm;
use regex::Regex;
use serde::Serialize;
use std::path::Path;
use std::sync::OnceLock;
use tracing::info;

use crate::config::Config;
use crate::git;
use crate::state::InkState;

// ─── Shared regex (compiled once) ────────────────────────────────────────────

/// Returns the compiled regex for author INK instructions.
/// The mandatory space after `INK:` ensures engine markers are never matched.
/// Must stay consistent with context.rs.
fn ink_re() -> &'static Regex {
    static RE: OnceLock<Regex> = OnceLock::new();
    RE.get_or_init(|| Regex::new(r"<!-- INK: (.*?) -->").unwrap())
}

// ─── Output types ─────────────────────────────────────────────────────────────

#[derive(Debug, Serialize)]
pub struct ClosePayload {
    pub session_word_count: u32,
    pub expected_words_per_session: u32,
    pub total_word_count: u32,
    pub target_length: u32,
    pub completion_ready: bool,
    pub current_chapter_word_count: u32,
    pub status: &'static str,
}

// ─── Helpers ──────────────────────────────────────────────────────────────────

const FULL_BOOK_HEADER: &str = "<!-- ⚠ INK-GATEWAY:MANAGED — Do not edit this file directly.\n\
     Human edits belong in Review/current.md.\n\
     Validated content is appended automatically after each session.\n\
     Use `ink-cli rollback` to undo the last session. -->";

/// Find the byte position of the first author instruction comment `<!-- INK: ` in `content`.
/// Deliberately does NOT match engine markers `<!-- INK:NEW:` or `<!-- INK:REWORKED:`.
fn find_first_ink_instruction(content: &str) -> Option<usize> {
    let mut search_from = 0;
    while let Some(rel) = content[search_from..].find("<!-- INK:") {
        let abs = search_from + rel;
        // Check for the space that distinguishes author instructions from engine markers
        let after = &content[abs + 9..]; // skip "<!-- INK:"
        if after.starts_with(' ') {
            return Some(abs);
        }
        search_from = abs + 9;
    }
    None
}

/// Extract author INK instructions from `content`.
/// Returns (content with all `<!-- INK: ... -->` comments removed, Vec<(anchor, instruction)>).
/// The mandatory space after `INK:` ensures engine markers (`<!-- INK:NEW: -->`) are never matched.
fn extract_author_instructions(content: &str) -> (String, Vec<(String, String)>) {
    let re = ink_re();
    let mut instructions: Vec<(String, String)> = Vec::new();

    for cap in re.captures_iter(content) {
        let full_match = cap.get(0).expect("full match");
        let instruction = cap[1].trim().to_string();

        // Anchor = last 200 chars of text preceding the comment (mirrors context.rs)
        let preceding = content[..full_match.start()].trim_end();
        let anchor_start = if preceding.len() > 200 {
            preceding.len() - 200
        } else {
            0
        };
        let anchor = preceding[anchor_start..].to_string();

        instructions.push((anchor, instruction));
    }

    let stripped = re.replace_all(content, "").to_string();
    (stripped, instructions)
}

/// Strip engine-generated INK markers from prose before it enters Full_Book.md.
/// Per spec, `<!-- INK:NEW:START/END -->` and `<!-- INK:REWORKED:START/END -->` markers
/// live only in `current.md` and must never appear in the validated vault.
fn strip_engine_markers(text: &str) -> String {
    text.lines()
        .filter(|l| {
            let t = l.trim();
            !matches!(
                t,
                "<!-- INK:NEW:START -->"
                    | "<!-- INK:NEW:END -->"
                    | "<!-- INK:REWORKED:START -->"
                    | "<!-- INK:REWORKED:END -->"
            )
        })
        .collect::<Vec<_>>()
        .join("\n")
}

/// Count prose words, ignoring HTML comment lines (e.g. `<!-- PAGE N -->`).
/// Used by both session-close (maintenance) and session-open word_count (context)
/// so both always report the same figure.
pub fn count_prose_words(content: &str) -> u32 {
    content
        .lines()
        .filter(|l| !l.trim_start().starts_with("<!--"))
        .flat_map(|l| l.split_whitespace())
        .count() as u32
}

/// Insert `<!-- PAGE N -->` markers into `new_content` at paragraph boundaries
/// closest to each `words_per_page` boundary, given that the book already has
/// `start_word_count` prose words before this content.
fn insert_pagination(start_word_count: u32, new_content: &str, words_per_page: u32) -> String {
    if words_per_page == 0 {
        return new_content.to_string();
    }

    let mut chunks: Vec<String> = Vec::new();
    let mut cumulative = start_word_count;
    // First boundary we haven't yet marked
    let mut next_mark = ((start_word_count / words_per_page) + 1) * words_per_page;

    for para in new_content.split("\n\n") {
        let para = para.trim();
        if para.is_empty() {
            continue;
        }
        let para_words = para.split_whitespace().count() as u32;

        // Insert marker(s) for every boundary this paragraph crosses or lands on
        while cumulative < next_mark && cumulative + para_words >= next_mark {
            let page_num = next_mark / words_per_page + 1;
            chunks.push(format!("<!-- PAGE {} -->", page_num));
            next_mark += words_per_page;
        }

        chunks.push(para.to_string());
        cumulative += para_words;
    }

    chunks.join("\n\n")
}

/// Append `content` to `Full_Book.md` at `book_path` with pagination markers.
/// Creates the file (with managed header) if it doesn't exist.
/// Returns `(old_word_count, new_word_count)` — both computed in a single read,
/// so callers don't need a separate pre-read to calculate words_added.
fn append_to_full_book(book_path: &Path, content: &str, words_per_page: u32) -> Result<(u32, u32)> {
    let mut book = if book_path.exists() {
        std::fs::read_to_string(book_path).with_context(|| "Failed to read Full_Book.md")?
    } else {
        format!("{}\n", FULL_BOOK_HEADER)
    };

    let old_words = count_prose_words(&book);
    let paginated = insert_pagination(old_words, content.trim(), words_per_page);

    if !book.ends_with('\n') {
        book.push('\n');
    }
    book.push('\n');
    book.push_str(&paginated);
    if !book.ends_with('\n') {
        book.push('\n');
    }

    let new_words = count_prose_words(&book);
    std::fs::write(book_path, &book).with_context(|| "Failed to write Full_Book.md")?;
    Ok((old_words, new_words))
}

// ─── README helpers ────────────────────────────────────────────────────────────

/// Extract the first Markdown heading from `content` as a plain string.
/// Falls back to "Chapter N" if no heading is found.
fn extract_chapter_title(content: &str, chapter_num: u32) -> String {
    content
        .lines()
        .find_map(|line| {
            let stripped = line.trim_start_matches('#').trim();
            if line.starts_with('#') && !stripped.is_empty() {
                Some(stripped.to_string())
            } else {
                None
            }
        })
        .unwrap_or_else(|| format!("Chapter {}", chapter_num))
}

/// Rebuild the chapter list section in README.md.
///
/// Chapters 1..=`completed_through` are marked ✓.
/// `in_progress` (if Some) is marked *(in progress)*.
/// Chapters beyond `in_progress` (or `completed_through` when None) are not listed.
///
/// The section is delimited by the `<!-- INK:README:CHAPTERS -->` marker and the
/// next `\n---` separator. Non-fatal if README.md is absent or the marker is missing.
fn update_readme_chapters(
    repo: &Path,
    completed_through: u32,
    in_progress: Option<u32>,
) -> Result<()> {
    let readme_path = repo.join("README.md");
    if !readme_path.exists() {
        return Ok(());
    }

    const MARKER: &str = "<!-- INK:README:CHAPTERS -->";
    let content =
        std::fs::read_to_string(&readme_path).with_context(|| "Failed to read README.md")?;

    let Some(marker_pos) = content.find(MARKER) else {
        return Ok(());
    };

    // Build the chapter list
    let last = in_progress.unwrap_or(completed_through);
    let mut list = String::new();
    for i in 1..=last {
        let chapter_path = repo
            .join("Chapters material")
            .join(format!("Chapter_{:02}.md", i));
        let title = if chapter_path.exists() {
            let ch = std::fs::read_to_string(&chapter_path).unwrap_or_default();
            extract_chapter_title(&ch, i)
        } else {
            format!("Chapter {}", i)
        };
        let suffix = if Some(i) == in_progress {
            " *(in progress)*"
        } else {
            " ✓"
        };
        list.push_str(&format!("{}. **{}**{}\n", i, title, suffix));
    }

    // Replace from the marker line to the next \n--- separator (kept intact)
    let after_marker = &content[marker_pos + MARKER.len()..];
    let sep_offset = after_marker.find("\n---").unwrap_or(after_marker.len());

    let new_content = format!(
        "{}{}\n\n{}{}",
        &content[..marker_pos],
        MARKER,
        list,
        &after_marker[sep_offset..]
    );

    std::fs::write(&readme_path, new_content).with_context(|| "Failed to write README.md")?;
    Ok(())
}

/// Update the `- **Status:**` line in README.md to `new_status`.
/// Non-fatal if README.md is absent.
fn update_readme_status(repo: &Path, new_status: &str) -> Result<()> {
    let readme_path = repo.join("README.md");
    if !readme_path.exists() {
        return Ok(());
    }
    let content =
        std::fs::read_to_string(&readme_path).with_context(|| "Failed to read README.md")?;
    let updated = content
        .lines()
        .map(|line| {
            if line.trim_start().starts_with("- **Status:**") {
                format!("- **Status:** {}", new_status)
            } else {
                line.to_string()
            }
        })
        .collect::<Vec<_>>()
        .join("\n");
    std::fs::write(&readme_path, updated).with_context(|| "Failed to write README.md")?;
    Ok(())
}

// ─── session-close ─────────────────────────────────────────────────────────────

pub fn close_session(
    repo: &Path,
    prose: &str,
    summary: Option<&str>,
    human_edits: &[String],
) -> Result<ClosePayload> {
    let lock_path = repo.join(".ink-running");

    // Guard: lock must exist
    if !lock_path.exists() {
        return Err(anyhow!("no active session — run session-open first"));
    }

    let config = Config::load(repo)?;
    let now = Local::now();
    let session_word_count = prose.split_whitespace().count() as u32;

    // ── Step 1: Read old current.md, split at first INK instruction ──────────
    info!("Reading Review/current.md to extract validated content");
    let review_dir = repo.join("Review");
    let current_md_path = review_dir.join("current.md");

    let old_current = if current_md_path.exists() {
        std::fs::read_to_string(&current_md_path)
            .with_context(|| "Failed to read Review/current.md")?
    } else {
        String::new()
    };

    // Everything before the first author INK instruction is validated prose.
    // The pending section (from the first instruction onwards) is tracked separately:
    // if the engine skips rework, we carry it forward so instructions aren't silently lost.
    let (validated, pending_opt) = match find_first_ink_instruction(&old_current) {
        Some(pos) => (
            old_current[..pos].trim_end().to_string(),
            Some(old_current[pos..].trim_start().to_string()),
        ),
        None => (old_current.trim_end().to_string(), None), // no instructions → all is validated
    };

    // ── Step 2: Append validated content to Full_Book.md ────────────────────
    info!("Appending validated content to Full_Book.md");
    let book_dir = repo.join("Current version");
    std::fs::create_dir_all(&book_dir).with_context(|| "Failed to create 'Current version/'")?;
    let book_path = book_dir.join("Full_Book.md");

    // Strip engine markers before appending — they belong only in current.md.
    let validated = strip_engine_markers(&validated);

    // append_to_full_book returns (old_words, new_words) from a single file read,
    // eliminating the separate pre-read that was needed before.
    let (old_total, total_word_count) = if !validated.trim().is_empty() {
        append_to_full_book(&book_path, validated.trim(), config.words_per_page)?
    } else {
        // Nothing validated: no words added; report current book word count
        let existing = if book_path.exists() {
            count_prose_words(
                &std::fs::read_to_string(&book_path)
                    .with_context(|| "Failed to read Full_Book.md")?,
            )
        } else {
            0
        };
        (existing, existing)
    };

    // ── Step 2b: Update chapter word count in .ink-state.yml ────────────────
    info!("Updating chapter word count in .ink-state.yml");
    let words_added = total_word_count.saturating_sub(old_total);
    let mut state = InkState::load(repo)?;
    state.current_chapter_word_count += words_added;
    state.save(repo)?;

    // ── Step 3: Write new current.md = engine prose (REWORKED + NEW blocks) ──
    //
    // Guard: if old current.md had pending INK instructions but the engine
    // produced no REWORKED blocks, the rework was silently skipped.
    // Carry the pending section forward so instructions surface again in the
    // next session-open payload instead of being permanently discarded.
    let new_current = match pending_opt {
        Some(ref pending) if !prose.contains("<!-- INK:REWORKED:START -->") => {
            let instruction_count = ink_re().find_iter(pending).count();
            tracing::warn!(
                "Engine produced 0 REWORKED blocks despite {} pending INK instruction(s); \
                 carrying pending section forward to next session",
                instruction_count
            );
            // Strip stale engine markers from pending before re-appending so they
            // don't accumulate across sessions (markers belong only in current.md
            // when freshly generated, not when preserved from a prior session).
            let pending_clean = strip_engine_markers(pending);
            format!("{}\n\n{}", prose.trim_end(), pending_clean.trim())
        }
        _ => prose.to_string(),
    };

    info!("Writing new Review/current.md");
    std::fs::create_dir_all(&review_dir).with_context(|| "Failed to create Review/")?;
    std::fs::write(&current_md_path, &new_current)
        .with_context(|| "Failed to write Review/current.md")?;

    // ── Step 4: Append to Summary.md ─────────────────────────────────────────
    info!("Appending to Summary.md");
    let summary_path = repo.join("Global Material").join("Summary.md");
    let delta_text = summary.map(|s| s.to_string()).unwrap_or_else(|| {
        format!(
            "Session {} — {} words written.",
            now.format("%Y-%m-%d %H:%M"),
            session_word_count
        )
    });
    let delta = format!("\n\n{}", delta_text.trim());
    let mut existing_summary = if summary_path.exists() {
        std::fs::read_to_string(&summary_path).with_context(|| "Failed to read Summary.md")?
    } else {
        String::new()
    };
    existing_summary.push_str(&delta);
    std::fs::write(&summary_path, &existing_summary)
        .with_context(|| "Failed to write Summary.md")?;

    // ── Step 5: Write Changelog entry ────────────────────────────────────────
    info!("Writing changelog entry");
    let changelog_dir = repo.join("Changelog");
    std::fs::create_dir_all(&changelog_dir).with_context(|| "Failed to create Changelog/")?;
    let changelog_filename = format!("{}.md", now.format("%Y-%m-%d-%H-%M"));
    let changelog_path = changelog_dir.join(&changelog_filename);

    let mut changelog = format!(
        "# Session {}\n\n**Words written:** {}\n",
        now.format("%Y-%m-%d %H:%M"),
        session_word_count
    );
    if !human_edits.is_empty() {
        changelog.push_str("\n**Human edits:**\n");
        for edit in human_edits {
            changelog.push_str(&format!("- {}\n", edit));
        }
    }
    if let Some(s) = summary {
        changelog.push_str(&format!("\n**Summary:**\n{}\n", s.trim()));
    }

    std::fs::write(&changelog_path, &changelog)
        .with_context(|| format!("Failed to write {}", changelog_path.display()))?;

    // ── Step 6: Commit and push ───────────────────────────────────────────────
    info!("Committing session on draft branch");
    git::run_git(repo, &["rm", "-f", ".ink-running"])
        .with_context(|| "Failed to git rm .ink-running")?;
    git::run_git(repo, &["add", "-A"]).with_context(|| "Failed to git add session files")?;
    git::run_git(repo, &["commit", "-m", "session: write prose"])
        .with_context(|| "Failed to commit session files")?;
    git::run_git(repo, &["push", "origin", "draft"]).with_context(|| "Failed to push draft")?;

    info!("Fast-forward merging draft into main and pushing");
    git::run_git(repo, &["checkout", "main"]).with_context(|| "Failed to checkout main")?;
    git::run_git(repo, &["merge", "--ff-only", "draft"])
        .with_context(|| "Failed to fast-forward merge draft into main")?;
    git::run_git(repo, &["push", "origin", "main"]).with_context(|| "Failed to push main")?;

    let completion_ready = total_word_count >= (config.target_length as f64 * 0.9) as u32;

    Ok(ClosePayload {
        session_word_count,
        expected_words_per_session: config.words_per_session,
        total_word_count,
        target_length: config.target_length,
        completion_ready,
        current_chapter_word_count: state.current_chapter_word_count,
        status: "closed",
    })
}

// ─── complete ─────────────────────────────────────────────────────────────────

/// Check for pending author INK instructions in current.md.
/// Returns `needs_revision` JSON if any found, or finalizes and returns `complete` JSON.
pub fn complete_session(repo: &Path) -> Result<serde_json::Value> {
    let complete_path = repo.join("COMPLETE");

    // Guard: COMPLETE must not already exist
    if complete_path.exists() {
        return Err(anyhow!(
            "book already complete — COMPLETE marker already exists"
        ));
    }

    // Ensure we're on main
    git::run_git(repo, &["checkout", "main"])
        .with_context(|| "Failed to checkout main for complete")?;

    // Read current.md
    let current_md_path = repo.join("Review").join("current.md");
    let current_content = if current_md_path.exists() {
        std::fs::read_to_string(&current_md_path)
            .with_context(|| "Failed to read Review/current.md")?
    } else {
        String::new()
    };

    // Check for pending author INK instructions
    let (stripped_content, instructions) = extract_author_instructions(&current_content);

    if !instructions.is_empty() {
        // Pending revisions — engine must run another session loop before finalizing
        let instructions_json: Vec<serde_json::Value> = instructions
            .into_iter()
            .map(|(anchor, instruction)| {
                serde_json::json!({
                    "anchor": anchor,
                    "instruction": instruction,
                })
            })
            .collect();

        return Ok(serde_json::json!({
            "status": "needs_revision",
            "current_review": {
                "content": stripped_content,
                "instructions": instructions_json,
            }
        }));
    }

    // ── No instructions: finalize the book ───────────────────────────────────
    info!("No pending INK instructions — finalizing book");

    // Strip engine markers before the final append — they must not appear in Full_Book.md.
    let current_content = strip_engine_markers(&current_content);

    // Append entire current.md to Full_Book.md (it's all validated at this point)
    let config = Config::load(repo)?;
    let book_dir = repo.join("Current version");
    std::fs::create_dir_all(&book_dir).with_context(|| "Failed to create 'Current version/'")?;
    let book_path = book_dir.join("Full_Book.md");

    let total_word_count = if !current_content.trim().is_empty() {
        let (_, new_total) =
            append_to_full_book(&book_path, &current_content, config.words_per_page)?;
        new_total
    } else if book_path.exists() {
        let content = std::fs::read_to_string(&book_path)
            .with_context(|| "Failed to read Full_Book.md for word count")?;
        count_prose_words(&content)
    } else {
        0
    };

    // Write completion placeholder to current.md
    let placeholder =
        "<!-- Book complete. This file is sealed. See Full_Book.md for the final text. -->";
    std::fs::write(&current_md_path, placeholder)
        .with_context(|| "Failed to write completion placeholder to Review/current.md")?;

    // Remove stale .ink-running lock if present
    let lock_path = repo.join(".ink-running");
    if lock_path.exists() {
        git::run_git(repo, &["rm", "-f", ".ink-running"])
            .with_context(|| "Failed to git rm .ink-running")?;
    }

    // Write COMPLETE marker
    info!("Writing COMPLETE marker");
    std::fs::write(&complete_path, "").with_context(|| "Failed to write COMPLETE")?;

    // Update README: mark all chapters ✓ and set final status
    let state = InkState::load(repo).unwrap_or_default();
    let chapter_word = if state.current_chapter == 1 {
        "chapter"
    } else {
        "chapters"
    };
    let _ = update_readme_chapters(repo, state.current_chapter, None);
    let _ = update_readme_status(
        repo,
        &format!(
            "Complete — {} {}, {} words",
            state.current_chapter, chapter_word, total_word_count
        ),
    );

    // Commit and push main + draft so both branches reflect the sealed book
    git::run_git(repo, &["add", "-A"]).with_context(|| "Failed to git add for final seal")?;
    git::run_git(repo, &["commit", "-m", "book: complete — final seal"])
        .with_context(|| "Failed to commit completion")?;
    git::run_git(repo, &["push", "origin", "main"])
        .with_context(|| "Failed to push main for completion")?;

    // Keep draft in sync — best-effort, not fatal if draft never existed
    if git::run_git(repo, &["show-ref", "--verify", "refs/heads/draft"]).is_ok() {
        git::run_git(repo, &["branch", "-f", "draft", "main"])
            .with_context(|| "Failed to fast-forward draft to main")?;
        if let Err(e) = git::run_git(repo, &["push", "origin", "draft"]) {
            tracing::warn!("Could not push draft after completion (non-fatal): {}", e);
        }
    }

    Ok(serde_json::json!({
        "status": "complete",
        "total_word_count": total_word_count,
    }))
}

// ─── advance-chapter ──────────────────────────────────────────────────────────

/// Advance to the next chapter by updating `.ink-state.yml`.
/// Returns `needs_chapter_outline` if the next chapter file is missing,
/// or `advanced` with the new chapter content on success.
/// Does NOT push — session-close handles all pushes.
pub fn advance_chapter(repo: &Path) -> Result<serde_json::Value> {
    let config = Config::load(repo)?;
    let mut state = InkState::load(repo)?;

    let next_chapter = state.current_chapter + 1;

    if next_chapter > config.chapter_count {
        return Ok(serde_json::json!({
            "status": "error",
            "message": format!("Already at last chapter ({}/{})", state.current_chapter, config.chapter_count),
        }));
    }

    // Guard: chapter must have reached ≥ 90 % of words_per_chapter
    let min_words = (config.words_per_chapter as f64 * 0.9) as u32;
    if state.current_chapter_word_count < min_words {
        return Ok(serde_json::json!({
            "status": "chapter_not_ready",
            "current_word_count": state.current_chapter_word_count,
            "target_word_count": config.words_per_chapter,
            "min_words_to_advance": min_words,
        }));
    }

    let chapter_filename = format!("Chapter_{:02}.md", next_chapter);
    let chapter_rel = format!("Chapters material/{}", chapter_filename);
    let chapter_path = repo.join(&chapter_rel);

    if !chapter_path.exists() {
        return Ok(serde_json::json!({
            "status": "needs_chapter_outline",
            "chapter": next_chapter,
            "chapter_file": chapter_rel,
        }));
    }

    let chapter_content = std::fs::read_to_string(&chapter_path)
        .with_context(|| format!("Failed to read {}", chapter_rel))?;

    // Advance state
    state.current_chapter = next_chapter;
    state.current_chapter_word_count = 0;
    state.save(repo)?;

    // Update README: mark previous chapter ✓, new chapter in progress
    update_readme_chapters(repo, next_chapter - 1, Some(next_chapter))?;
    update_readme_status(repo, &format!("In progress — Chapter {}", next_chapter))?;

    // Commit the state update (and chapter file + README if present)
    let readme_exists = repo.join("README.md").exists();
    let mut add_args = vec!["add", ".ink-state.yml", &chapter_rel];
    if readme_exists {
        add_args.push("README.md");
    }
    git::run_git(repo, &add_args).with_context(|| "Failed to git add for chapter advance")?;
    git::run_git(
        repo,
        &[
            "commit",
            "-m",
            &format!("chapter: advance to chapter {}", next_chapter),
        ],
    )
    .with_context(|| "Failed to commit chapter advance")?;

    info!("Advanced to chapter {}", next_chapter);

    Ok(serde_json::json!({
        "status": "advanced",
        "new_chapter": next_chapter,
        "chapter_file": chapter_rel,
        "chapter_content": chapter_content,
    }))
}

// ─── status ───────────────────────────────────────────────────────────────────

/// Return a lightweight read-only JSON snapshot of the book's current state.
/// Reads only local files — no git operations, no network.
pub fn book_status(repo: &Path) -> Result<serde_json::Value> {
    let state = InkState::load(repo)?;
    let config = Config::load(repo).ok();

    let book_path = repo.join("Current version").join("Full_Book.md");
    let total_word_count = if book_path.exists() {
        let content =
            std::fs::read_to_string(&book_path).with_context(|| "Failed to read Full_Book.md")?;
        count_prose_words(&content)
    } else {
        0
    };

    let lock_path = repo.join(".ink-running");
    let lock_age_seconds = crate::context::read_lock_age(repo);
    let complete = repo.join("COMPLETE").exists();
    let initialized = repo.join("Global Material").join("Config.yml").exists();

    let (
        target_length,
        words_per_chapter,
        words_per_session,
        chapter_close_suggested,
        completion_ready,
    ) = match &config {
        Some(c) => (
            c.target_length,
            c.words_per_chapter,
            c.words_per_session,
            state.current_chapter_word_count >= (c.words_per_chapter as f64 * 0.9) as u32,
            total_word_count >= (c.target_length as f64 * 0.9) as u32,
        ),
        None => (0, 0, 0, false, false),
    };

    Ok(serde_json::json!({
        "initialized": initialized,
        "complete": complete,
        "current_chapter": state.current_chapter,
        "current_chapter_word_count": state.current_chapter_word_count,
        "words_per_chapter": words_per_chapter,
        "chapter_close_suggested": chapter_close_suggested,
        "total_word_count": total_word_count,
        "target_length": target_length,
        "words_per_session": words_per_session,
        "completion_ready": completion_ready,
        "session_active": lock_path.exists(),
        "session_age_seconds": lock_age_seconds,
    }))
}

// ─── doctor ───────────────────────────────────────────────────────────────────

/// Validate the book repository structure and return a list of issues.
/// Checks file presence, Config.yml validity, git remote, draft branch, and lock state.
/// Note: the `git_remote_reachable` check makes a network call and may be slow on an
/// unreachable remote — all other checks are local-only.
pub fn doctor(repo: &Path) -> Result<serde_json::Value> {
    let mut checks: Vec<serde_json::Value> = Vec::new();
    let mut all_ok = true;

    macro_rules! check {
        ($name:expr, $ok:expr, $detail:expr) => {{
            let ok: bool = $ok;
            if !ok { all_ok = false; }
            checks.push(serde_json::json!({
                "name": $name,
                "ok": ok,
                "detail": $detail,
            }));
        }};
    }

    // ── Required Global Material files ───────────────────────────────────────
    for filename in &[
        "Config.yml",
        "Soul.md",
        "Outline.md",
        "Characters.md",
        "Lore.md",
    ] {
        let path = repo.join("Global Material").join(filename);
        check!(
            format!("global_{}", filename.to_lowercase().replace('.', "_")),
            path.exists(),
            if path.exists() {
                serde_json::Value::Null
            } else {
                serde_json::json!(format!("Global Material/{filename} not found"))
            }
        );
    }

    // ── Config.yml parses and validates ──────────────────────────────────────
    match Config::load(repo) {
        Ok(cfg) => {
            check!("config_valid", true, serde_json::Value::Null);

            // ── Current chapter outline exists ────────────────────────────
            let state = InkState::load(repo).unwrap_or_default();
            let chapter_file = format!("Chapters material/Chapter_{:02}.md", state.current_chapter);
            let chapter_path = repo.join(&chapter_file);
            check!(
                "current_chapter_outline",
                chapter_path.exists(),
                if chapter_path.exists() {
                    serde_json::Value::Null
                } else {
                    serde_json::json!(format!("{chapter_file} not found"))
                }
            );

            // ── Words-per-session sanity ──────────────────────────────────
            let sane = cfg.words_per_session >= 100 && cfg.words_per_session <= 10_000;
            check!(
                "words_per_session_sane",
                sane,
                if sane {
                    serde_json::Value::Null
                } else {
                    serde_json::json!(format!(
                        "words_per_session={} — expected 100–10000",
                        cfg.words_per_session
                    ))
                }
            );
        }
        Err(e) => {
            check!("config_valid", false, serde_json::json!(e.to_string()));
            // Skip chapter check — can't read state without a valid config dir
        }
    }

    // ── Review/current.md ────────────────────────────────────────────────────
    let current_md = repo.join("Review").join("current.md");
    check!(
        "current_md",
        current_md.exists(),
        if current_md.exists() {
            serde_json::Value::Null
        } else {
            serde_json::json!("Review/current.md not found — run init first")
        }
    );

    // ── Git remote configured ─────────────────────────────────────────────────
    let remote_url = git::run_git(repo, &["remote", "get-url", "origin"]);
    check!(
        "git_remote_configured",
        remote_url.is_ok(),
        match &remote_url {
            Ok(url) => serde_json::json!(url),
            Err(e) => serde_json::json!(e.to_string()),
        }
    );

    // ── Git remote reachable (network call) ───────────────────────────────────
    if remote_url.is_ok() {
        match git::run_git(repo, &["ls-remote", "--exit-code", "--heads", "origin"]) {
            Ok(_) => check!("git_remote_reachable", true, serde_json::Value::Null),
            Err(e) => check!(
                "git_remote_reachable",
                false,
                serde_json::json!(e.to_string())
            ),
        }
    }

    // ── Draft branch exists locally ───────────────────────────────────────────
    let draft_exists = git::run_git(repo, &["show-ref", "--verify", "refs/heads/draft"]).is_ok();
    check!(
        "draft_branch",
        draft_exists,
        if draft_exists {
            serde_json::Value::Null
        } else {
            serde_json::json!(
                "draft branch not found locally — will be created at next session-open"
            )
        }
    );

    // ── Session lock ──────────────────────────────────────────────────────────
    let lock_path = repo.join(".ink-running");
    if lock_path.exists() {
        let age = crate::context::read_lock_age(repo);
        let timeout = Config::load(repo)
            .map(|c| c.session_timeout_minutes)
            .unwrap_or(60);
        let stale = age.map(|a| a > timeout).unwrap_or(false);
        check!(
            "session_lock",
            !stale,
            serde_json::json!(format!(
                "lock exists (age: {}m, timeout: {}m) — {}",
                age.unwrap_or(-1),
                timeout,
                if stale {
                    "STALE — will be recovered at next session-open"
                } else {
                    "active session in progress"
                }
            ))
        );
    } else {
        check!("session_lock", true, serde_json::Value::Null);
    }

    Ok(serde_json::json!({
        "status": if all_ok { "healthy" } else { "issues" },
        "checks": checks,
    }))
}

// ─── rollback ─────────────────────────────────────────────────────────────────

/// Revert main (and draft) to the snapshot tag created at the start of the
/// last writing session, undoing all prose generated in that session.
pub fn rollback_session(repo_path: &Path) -> Result<()> {
    // Collect all ink-* tags and sort reverse-chronologically.
    let raw = git::run_git(repo_path, &["tag", "-l", "ink-*"])?;
    let mut tags: Vec<&str> = raw
        .lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty())
        .collect();
    tags.sort_by(|a, b| b.cmp(a));

    let target = tags
        .first()
        .ok_or_else(|| anyhow::anyhow!("No ink-* snapshot tags found — nothing to roll back"))?;

    println!("\n  Rollback target : {}", target);
    if let Some(prev) = tags.get(1) {
        println!("  Previous snapshot: {}", prev);
    }
    println!();
    println!("  This will permanently remove the last session's prose,");
    println!("  Summary.md entry, and Changelog entry, then force-push.");

    let confirmed = Confirm::new("Confirm rollback?")
        .with_default(false)
        .prompt()
        .with_context(|| "Failed to read confirmation")?;

    if !confirmed {
        println!("  Rollback cancelled.");
        return Ok(());
    }

    // Ensure we're on main before resetting
    git::run_git(repo_path, &["checkout", "main"]).with_context(|| "Failed to checkout main")?;

    // Hard reset main to the snapshot tag
    git::run_git(repo_path, &["reset", "--hard", target])
        .with_context(|| format!("Failed to reset to {}", target))?;

    // Force-push main
    git::run_git(repo_path, &["push", "--force", "origin", "main"])
        .with_context(|| "Failed to force-push main")?;

    // Reset draft to main if it exists
    if git::run_git(repo_path, &["show-ref", "--verify", "refs/heads/draft"]).is_ok() {
        git::run_git(repo_path, &["branch", "-f", "draft", "main"])
            .with_context(|| "Failed to reset draft branch")?;
        git::run_git(repo_path, &["push", "--force", "origin", "draft"])
            .with_context(|| "Failed to force-push draft")?;
    }

    println!("\n  Rolled back to {}.", target);
    println!("  The last session's prose has been removed.");
    println!("  Run the next session normally when ready.\n");

    Ok(())
}

// ─── Tests ────────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn count_words_ignores_html_comment_lines() {
        let content = "Hello world\n<!-- PAGE 1 -->\nFoo bar baz";
        assert_eq!(count_prose_words(content), 5);
    }

    #[test]
    fn count_words_empty_input() {
        assert_eq!(count_prose_words(""), 0);
    }

    #[test]
    fn find_instruction_matches_author_comment() {
        let content = "Some prose\n<!-- INK: make this better -->\nMore prose";
        assert!(find_first_ink_instruction(content).is_some());
    }

    #[test]
    fn find_instruction_ignores_engine_new_marker() {
        let content = "<!-- INK:NEW:START -->\nProse\n<!-- INK:NEW:END -->";
        assert!(find_first_ink_instruction(content).is_none());
    }

    #[test]
    fn find_instruction_ignores_engine_reworked_marker() {
        let content = "<!-- INK:REWORKED:START -->\nProse\n<!-- INK:REWORKED:END -->";
        assert!(find_first_ink_instruction(content).is_none());
    }

    #[test]
    fn find_instruction_skips_engine_markers_to_find_author() {
        let content = "<!-- INK:NEW:START -->\nProse\n<!-- INK:NEW:END -->\n<!-- INK: fix this -->";
        let pos = find_first_ink_instruction(content).expect("should find author instruction");
        assert!(content[pos..].starts_with("<!-- INK: fix this -->"));
    }

    #[test]
    fn strip_engine_markers_removes_start_end_lines() {
        let content = "Before\n<!-- INK:NEW:START -->\nNew prose\n<!-- INK:NEW:END -->\nAfter";
        let stripped = strip_engine_markers(content);
        assert!(!stripped.contains("<!-- INK:NEW:START -->"));
        assert!(!stripped.contains("<!-- INK:NEW:END -->"));
        assert!(stripped.contains("New prose"));
        assert!(stripped.contains("Before"));
        assert!(stripped.contains("After"));
    }

    #[test]
    fn strip_engine_markers_handles_reworked() {
        let content = "A\n<!-- INK:REWORKED:START -->\nB\n<!-- INK:REWORKED:END -->\nC";
        let stripped = strip_engine_markers(content);
        assert!(!stripped.contains("INK:REWORKED"));
        assert!(stripped.contains('B'));
    }

    #[test]
    fn pagination_inserts_marker_at_boundary() {
        // Build a single paragraph of 300 words; with words_per_page=250 and
        // start_word_count=0 there should be a PAGE 2 marker inserted.
        let para = "word ".repeat(300);
        let result = insert_pagination(0, para.trim(), 250);
        assert!(
            result.contains("<!-- PAGE 2 -->"),
            "expected PAGE 2 in: {result}"
        );
    }

    #[test]
    fn pagination_disabled_when_words_per_page_is_zero() {
        let content = "Some content here";
        let result = insert_pagination(0, content, 0);
        assert_eq!(result, content);
    }

    #[test]
    fn pagination_respects_existing_word_count() {
        // Already at 240 words; next page boundary is 250. A 20-word paragraph
        // should trigger a marker.
        let para = "word ".repeat(20);
        let result = insert_pagination(240, para.trim(), 250);
        assert!(
            result.contains("<!-- PAGE 2 -->"),
            "expected PAGE 2 in: {result}"
        );
    }

    #[test]
    fn session_close_guard_returns_err_without_lock() {
        let tmp = tempfile::tempdir().unwrap();
        let err = close_session(tmp.path(), "prose", None, &[]).unwrap_err();
        assert!(err.to_string().contains("no active session"));
    }

    #[test]
    fn complete_guard_returns_err_when_already_complete() {
        let tmp = tempfile::tempdir().unwrap();
        std::fs::write(tmp.path().join("COMPLETE"), "").unwrap();
        let err = complete_session(tmp.path()).unwrap_err();
        assert!(err.to_string().contains("already complete"));
    }

    // ── advance-chapter guard helpers ─────────────────────────────────────────

    fn write_test_config(dir: &std::path::Path, words_per_chapter: u32) {
        let global_dir = dir.join("Global Material");
        std::fs::create_dir_all(&global_dir).unwrap();
        let content = format!(
            "target_length: 80000\nchapter_count: 10\nchapter_structure: three-act\n\
             words_per_session: 800\nwords_per_chapter: {}\n",
            words_per_chapter
        );
        std::fs::write(global_dir.join("Config.yml"), content).unwrap();
    }

    fn write_test_state(dir: &std::path::Path, chapter: u32, word_count: u32) {
        let content = format!(
            "current_chapter: {}\ncurrent_chapter_word_count: {}\n",
            chapter, word_count
        );
        std::fs::write(dir.join(".ink-state.yml"), content).unwrap();
    }

    // ── advance-chapter guard tests ───────────────────────────────────────────

    #[test]
    fn advance_chapter_not_ready_below_threshold() {
        let tmp = tempfile::tempdir().unwrap();
        write_test_config(tmp.path(), 3000);
        write_test_state(tmp.path(), 1, 100);

        let result = advance_chapter(tmp.path()).unwrap();
        assert_eq!(result["status"], "chapter_not_ready");
        assert_eq!(result["current_word_count"], 100);
        assert_eq!(result["target_word_count"], 3000);
        assert_eq!(result["min_words_to_advance"], 2700);
    }

    #[test]
    fn advance_chapter_not_ready_at_zero_words() {
        let tmp = tempfile::tempdir().unwrap();
        write_test_config(tmp.path(), 3000);
        write_test_state(tmp.path(), 1, 0);

        let result = advance_chapter(tmp.path()).unwrap();
        assert_eq!(result["status"], "chapter_not_ready");
        assert_eq!(result["current_word_count"], 0);
    }

    // ── chapter_close_suggested formula tests (pure arithmetic, no I/O) ──────

    #[test]
    fn chapter_close_threshold_true_at_90_pct() {
        let words_per_chapter: u32 = 3000;
        let min: u32 = (words_per_chapter as f64 * 0.9) as u32; // 2700
        let current_word_count: u32 = 2700;
        assert!(current_word_count >= min);
    }

    #[test]
    fn chapter_close_threshold_false_below_90_pct() {
        let words_per_chapter: u32 = 3000;
        let min: u32 = (words_per_chapter as f64 * 0.9) as u32; // 2700
        let current_word_count: u32 = 2699;
        assert!(current_word_count < min);
    }
}
