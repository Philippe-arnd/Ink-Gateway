use anyhow::{Context, Result, anyhow};
use inquire::Confirm;
use chrono::Local;
use regex::Regex;
use serde::Serialize;
use std::path::Path;
use std::sync::OnceLock;
use tracing::info;

use crate::config::Config;
use crate::git;
use crate::state::InkState;

// ─── Shared regex (compiled once) ────────────────────────────────────────────

/// Returns the compiled regex for author INK instructions.
/// The mandatory space after `INK:` ensures engine markers are never matched.
/// Must stay consistent with context.rs.
fn ink_re() -> &'static Regex {
    static RE: OnceLock<Regex> = OnceLock::new();
    RE.get_or_init(|| Regex::new(r"<!-- INK: (.*?) -->").unwrap())
}

// ─── Output types ─────────────────────────────────────────────────────────────

#[derive(Debug, Serialize)]
pub struct ClosePayload {
    pub session_word_count: u32,
    pub expected_words_per_session: u32,
    pub total_word_count: u32,
    pub target_length: u32,
    pub completion_ready: bool,
    pub current_chapter_word_count: u32,
    pub status: &'static str,
}

// ─── Helpers ──────────────────────────────────────────────────────────────────

const FULL_BOOK_HEADER: &str =
    "<!-- ⚠ INK-GATEWAY:MANAGED — Do not edit this file directly.\n\
     Human edits belong in Review/current.md.\n\
     Validated content is appended automatically after each session.\n\
     Use `ink-cli rollback` to undo the last session. -->";

/// Find the byte position of the first author instruction comment `<!-- INK: ` in `content`.
/// Deliberately does NOT match engine markers `<!-- INK:NEW:` or `<!-- INK:REWORKED:`.
fn find_first_ink_instruction(content: &str) -> Option<usize> {
    let mut search_from = 0;
    while let Some(rel) = content[search_from..].find("<!-- INK:") {
        let abs = search_from + rel;
        // Check for the space that distinguishes author instructions from engine markers
        let after = &content[abs + 9..]; // skip "<!-- INK:"
        if after.starts_with(' ') {
            return Some(abs);
        }
        search_from = abs + 9;
    }
    None
}

/// Extract author INK instructions from `content`.
/// Returns (content with all `<!-- INK: ... -->` comments removed, Vec<(anchor, instruction)>).
/// The mandatory space after `INK:` ensures engine markers (`<!-- INK:NEW: -->`) are never matched.
fn extract_author_instructions(content: &str) -> (String, Vec<(String, String)>) {
    let re = ink_re();
    let mut instructions: Vec<(String, String)> = Vec::new();

    for cap in re.captures_iter(content) {
        let full_match = cap.get(0).expect("full match");
        let instruction = cap[1].trim().to_string();

        // Anchor = last 200 chars of text preceding the comment (mirrors context.rs)
        let preceding = content[..full_match.start()].trim_end();
        let anchor_start = if preceding.len() > 200 { preceding.len() - 200 } else { 0 };
        let anchor = preceding[anchor_start..].to_string();

        instructions.push((anchor, instruction));
    }

    let stripped = re.replace_all(content, "").to_string();
    (stripped, instructions)
}

/// Strip engine-generated INK markers from prose before it enters Full_Book.md.
/// Per spec, `<!-- INK:NEW:START/END -->` and `<!-- INK:REWORKED:START/END -->` markers
/// live only in `current.md` and must never appear in the validated vault.
fn strip_engine_markers(text: &str) -> String {
    text.lines()
        .filter(|l| {
            let t = l.trim();
            !matches!(
                t,
                "<!-- INK:NEW:START -->"
                    | "<!-- INK:NEW:END -->"
                    | "<!-- INK:REWORKED:START -->"
                    | "<!-- INK:REWORKED:END -->"
            )
        })
        .collect::<Vec<_>>()
        .join("\n")
}

/// Count prose words, ignoring HTML comment lines (e.g. `<!-- PAGE N -->`).
/// Used by both session-close (maintenance) and session-open word_count (context)
/// so both always report the same figure.
pub fn count_prose_words(content: &str) -> u32 {
    content
        .lines()
        .filter(|l| !l.trim_start().starts_with("<!--"))
        .flat_map(|l| l.split_whitespace())
        .count() as u32
}

/// Insert `<!-- PAGE N -->` markers into `new_content` at paragraph boundaries
/// closest to each `words_per_page` boundary, given that the book already has
/// `start_word_count` prose words before this content.
fn insert_pagination(start_word_count: u32, new_content: &str, words_per_page: u32) -> String {
    if words_per_page == 0 {
        return new_content.to_string();
    }

    let mut chunks: Vec<String> = Vec::new();
    let mut cumulative = start_word_count;
    // First boundary we haven't yet marked
    let mut next_mark = ((start_word_count / words_per_page) + 1) * words_per_page;

    for para in new_content.split("\n\n") {
        let para = para.trim();
        if para.is_empty() {
            continue;
        }
        let para_words = para.split_whitespace().count() as u32;

        // Insert marker(s) for every boundary this paragraph crosses or lands on
        while cumulative < next_mark && cumulative + para_words >= next_mark {
            let page_num = next_mark / words_per_page + 1;
            chunks.push(format!("<!-- PAGE {} -->", page_num));
            next_mark += words_per_page;
        }

        chunks.push(para.to_string());
        cumulative += para_words;
    }

    chunks.join("\n\n")
}

/// Append `content` to `Full_Book.md` at `book_path` with pagination markers.
/// Creates the file (with managed header) if it doesn't exist.
/// Returns `(old_word_count, new_word_count)` — both computed in a single read,
/// so callers don't need a separate pre-read to calculate words_added.
fn append_to_full_book(book_path: &Path, content: &str, words_per_page: u32) -> Result<(u32, u32)> {
    let mut book = if book_path.exists() {
        std::fs::read_to_string(book_path)
            .with_context(|| "Failed to read Full_Book.md")?
    } else {
        format!("{}\n", FULL_BOOK_HEADER)
    };

    let old_words = count_prose_words(&book);
    let paginated = insert_pagination(old_words, content.trim(), words_per_page);

    if !book.ends_with('\n') {
        book.push('\n');
    }
    book.push('\n');
    book.push_str(&paginated);
    if !book.ends_with('\n') {
        book.push('\n');
    }

    let new_words = count_prose_words(&book);
    std::fs::write(book_path, &book)
        .with_context(|| "Failed to write Full_Book.md")?;
    Ok((old_words, new_words))
}

// ─── session-close ─────────────────────────────────────────────────────────────

pub fn close_session(
    repo: &Path,
    prose: &str,
    summary: Option<&str>,
    human_edits: &[String],
) -> Result<ClosePayload> {
    let lock_path = repo.join(".ink-running");

    // Guard: lock must exist
    if !lock_path.exists() {
        return Err(anyhow!("no active session — run session-open first"));
    }

    let config = Config::load(repo)?;
    let now = Local::now();
    let session_word_count = prose.split_whitespace().count() as u32;

    // ── Step 1: Read old current.md, split at first INK instruction ──────────
    info!("Reading Review/current.md to extract validated content");
    let review_dir = repo.join("Review");
    let current_md_path = review_dir.join("current.md");

    let old_current = if current_md_path.exists() {
        std::fs::read_to_string(&current_md_path)
            .with_context(|| "Failed to read Review/current.md")?
    } else {
        String::new()
    };

    // Everything before the first author INK instruction is validated prose.
    // The pending section (from the first instruction onwards) is tracked separately:
    // if the engine skips rework, we carry it forward so instructions aren't silently lost.
    let (validated, pending_opt) = match find_first_ink_instruction(&old_current) {
        Some(pos) => (
            old_current[..pos].trim_end().to_string(),
            Some(old_current[pos..].trim_start().to_string()),
        ),
        None => (old_current.trim_end().to_string(), None), // no instructions → all is validated
    };

    // ── Step 2: Append validated content to Full_Book.md ────────────────────
    info!("Appending validated content to Full_Book.md");
    let book_dir = repo.join("Current version");
    std::fs::create_dir_all(&book_dir)
        .with_context(|| "Failed to create 'Current version/'")?;
    let book_path = book_dir.join("Full_Book.md");

    // Strip engine markers before appending — they belong only in current.md.
    let validated = strip_engine_markers(&validated);

    // append_to_full_book returns (old_words, new_words) from a single file read,
    // eliminating the separate pre-read that was needed before.
    let (old_total, total_word_count) = if !validated.trim().is_empty() {
        append_to_full_book(&book_path, validated.trim(), config.words_per_page)?
    } else {
        // Nothing validated: no words added; report current book word count
        let existing = if book_path.exists() {
            count_prose_words(&std::fs::read_to_string(&book_path)
                .with_context(|| "Failed to read Full_Book.md")?)
        } else {
            0
        };
        (existing, existing)
    };

    // ── Step 2b: Update chapter word count in .ink-state.yml ────────────────
    info!("Updating chapter word count in .ink-state.yml");
    let words_added = total_word_count.saturating_sub(old_total);
    let mut state = InkState::load(repo)?;
    state.current_chapter_word_count += words_added;
    state.save(repo)?;

    // ── Step 3: Write new current.md = engine prose (REWORKED + NEW blocks) ──
    //
    // Guard: if old current.md had pending INK instructions but the engine
    // produced no REWORKED blocks, the rework was silently skipped.
    // Carry the pending section forward so instructions surface again in the
    // next session-open payload instead of being permanently discarded.
    let new_current = match pending_opt {
        Some(ref pending) if !prose.contains("<!-- INK:REWORKED:START -->") => {
            let instruction_count = ink_re().find_iter(pending).count();
            tracing::warn!(
                "Engine produced 0 REWORKED blocks despite {} pending INK instruction(s); \
                 carrying pending section forward to next session",
                instruction_count
            );
            // Strip stale engine markers from pending before re-appending so they
            // don't accumulate across sessions (markers belong only in current.md
            // when freshly generated, not when preserved from a prior session).
            let pending_clean = strip_engine_markers(pending);
            format!("{}\n\n{}", prose.trim_end(), pending_clean.trim())
        }
        _ => prose.to_string(),
    };

    info!("Writing new Review/current.md");
    std::fs::create_dir_all(&review_dir)
        .with_context(|| "Failed to create Review/")?;
    std::fs::write(&current_md_path, &new_current)
        .with_context(|| "Failed to write Review/current.md")?;

    // ── Step 4: Append to Summary.md ─────────────────────────────────────────
    info!("Appending to Summary.md");
    let summary_path = repo.join("Global Material").join("Summary.md");
    let delta_text = summary
        .map(|s| s.to_string())
        .unwrap_or_else(|| {
            format!(
                "Session {} — {} words written.",
                now.format("%Y-%m-%d %H:%M"),
                session_word_count
            )
        });
    let delta = format!("\n\n{}", delta_text.trim());
    let mut existing_summary = if summary_path.exists() {
        std::fs::read_to_string(&summary_path)
            .with_context(|| "Failed to read Summary.md")?
    } else {
        String::new()
    };
    existing_summary.push_str(&delta);
    std::fs::write(&summary_path, &existing_summary)
        .with_context(|| "Failed to write Summary.md")?;

    // ── Step 5: Write Changelog entry ────────────────────────────────────────
    info!("Writing changelog entry");
    let changelog_dir = repo.join("Changelog");
    std::fs::create_dir_all(&changelog_dir)
        .with_context(|| "Failed to create Changelog/")?;
    let changelog_filename = format!("{}.md", now.format("%Y-%m-%d-%H-%M"));
    let changelog_path = changelog_dir.join(&changelog_filename);

    let mut changelog = format!(
        "# Session {}\n\n**Words written:** {}\n",
        now.format("%Y-%m-%d %H:%M"),
        session_word_count
    );
    if !human_edits.is_empty() {
        changelog.push_str("\n**Human edits:**\n");
        for edit in human_edits {
            changelog.push_str(&format!("- {}\n", edit));
        }
    }
    if let Some(s) = summary {
        changelog.push_str(&format!("\n**Summary:**\n{}\n", s.trim()));
    }

    std::fs::write(&changelog_path, &changelog)
        .with_context(|| format!("Failed to write {}", changelog_path.display()))?;

    // ── Step 6: Commit and push ───────────────────────────────────────────────
    info!("Committing session on draft branch");
    git::run_git(repo, &["rm", "-f", ".ink-running"])
        .with_context(|| "Failed to git rm .ink-running")?;
    git::run_git(repo, &["add", "-A"])
        .with_context(|| "Failed to git add session files")?;
    git::run_git(repo, &["commit", "-m", "session: write prose"])
        .with_context(|| "Failed to commit session files")?;
    git::run_git(repo, &["push", "origin", "draft"])
        .with_context(|| "Failed to push draft")?;

    info!("Fast-forward merging draft into main and pushing");
    git::run_git(repo, &["checkout", "main"])
        .with_context(|| "Failed to checkout main")?;
    git::run_git(repo, &["merge", "--ff-only", "draft"])
        .with_context(|| "Failed to fast-forward merge draft into main")?;
    git::run_git(repo, &["push", "origin", "main"])
        .with_context(|| "Failed to push main")?;

    let completion_ready = total_word_count >= (config.target_length as f64 * 0.9) as u32;

    Ok(ClosePayload {
        session_word_count,
        expected_words_per_session: config.words_per_session,
        total_word_count,
        target_length: config.target_length,
        completion_ready,
        current_chapter_word_count: state.current_chapter_word_count,
        status: "closed",
    })
}

// ─── complete ─────────────────────────────────────────────────────────────────

/// Check for pending author INK instructions in current.md.
/// Returns `needs_revision` JSON if any found, or finalizes and returns `complete` JSON.
pub fn complete_session(repo: &Path) -> Result<serde_json::Value> {
    let complete_path = repo.join("COMPLETE");

    // Guard: COMPLETE must not already exist
    if complete_path.exists() {
        return Err(anyhow!("book already complete — COMPLETE marker already exists"));
    }

    // Ensure we're on main
    git::run_git(repo, &["checkout", "main"])
        .with_context(|| "Failed to checkout main for complete")?;

    // Read current.md
    let current_md_path = repo.join("Review").join("current.md");
    let current_content = if current_md_path.exists() {
        std::fs::read_to_string(&current_md_path)
            .with_context(|| "Failed to read Review/current.md")?
    } else {
        String::new()
    };

    // Check for pending author INK instructions
    let (stripped_content, instructions) = extract_author_instructions(&current_content);

    if !instructions.is_empty() {
        // Pending revisions — engine must run another session loop before finalizing
        let instructions_json: Vec<serde_json::Value> = instructions
            .into_iter()
            .map(|(anchor, instruction)| serde_json::json!({
                "anchor": anchor,
                "instruction": instruction,
            }))
            .collect();

        return Ok(serde_json::json!({
            "status": "needs_revision",
            "current_review": {
                "content": stripped_content,
                "instructions": instructions_json,
            }
        }));
    }

    // ── No instructions: finalize the book ───────────────────────────────────
    info!("No pending INK instructions — finalizing book");

    // Strip engine markers before the final append — they must not appear in Full_Book.md.
    let current_content = strip_engine_markers(&current_content);

    // Append entire current.md to Full_Book.md (it's all validated at this point)
    let config = Config::load(repo)?;
    let book_dir = repo.join("Current version");
    std::fs::create_dir_all(&book_dir)
        .with_context(|| "Failed to create 'Current version/'")?;
    let book_path = book_dir.join("Full_Book.md");

    let total_word_count = if !current_content.trim().is_empty() {
        let (_, new_total) = append_to_full_book(&book_path, &current_content, config.words_per_page)?;
        new_total
    } else {
        if book_path.exists() {
            let content = std::fs::read_to_string(&book_path)
                .with_context(|| "Failed to read Full_Book.md for word count")?;
            count_prose_words(&content)
        } else {
            0
        }
    };

    // Write completion placeholder to current.md
    let placeholder = "<!-- Book complete. This file is sealed. See Full_Book.md for the final text. -->";
    std::fs::write(&current_md_path, placeholder)
        .with_context(|| "Failed to write completion placeholder to Review/current.md")?;

    // Remove stale .ink-running lock if present
    let lock_path = repo.join(".ink-running");
    if lock_path.exists() {
        git::run_git(repo, &["rm", "-f", ".ink-running"])
            .with_context(|| "Failed to git rm .ink-running")?;
    }

    // Write COMPLETE marker
    info!("Writing COMPLETE marker");
    std::fs::write(&complete_path, "")
        .with_context(|| "Failed to write COMPLETE")?;

    // Commit and push
    git::run_git(repo, &["add", "-A"])
        .with_context(|| "Failed to git add for final seal")?;
    git::run_git(repo, &["commit", "-m", "book: complete — final seal"])
        .with_context(|| "Failed to commit completion")?;
    git::run_git(repo, &["push", "origin", "main"])
        .with_context(|| "Failed to push completion")?;

    Ok(serde_json::json!({
        "status": "complete",
        "total_word_count": total_word_count,
    }))
}

// ─── advance-chapter ──────────────────────────────────────────────────────────

/// Advance to the next chapter by updating `.ink-state.yml`.
/// Returns `needs_chapter_outline` if the next chapter file is missing,
/// or `advanced` with the new chapter content on success.
/// Does NOT push — session-close handles all pushes.
pub fn advance_chapter(repo: &Path) -> Result<serde_json::Value> {
    let config = Config::load(repo)?;
    let mut state = InkState::load(repo)?;

    let next_chapter = state.current_chapter + 1;

    if next_chapter > config.chapter_count {
        return Ok(serde_json::json!({
            "status": "error",
            "message": format!("Already at last chapter ({}/{})", state.current_chapter, config.chapter_count),
        }));
    }

    let chapter_filename = format!("Chapter_{:02}.md", next_chapter);
    let chapter_rel = format!("Chapters material/{}", chapter_filename);
    let chapter_path = repo.join(&chapter_rel);

    if !chapter_path.exists() {
        return Ok(serde_json::json!({
            "status": "needs_chapter_outline",
            "chapter": next_chapter,
            "chapter_file": chapter_rel,
        }));
    }

    let chapter_content = std::fs::read_to_string(&chapter_path)
        .with_context(|| format!("Failed to read {}", chapter_rel))?;

    // Advance state
    state.current_chapter = next_chapter;
    state.current_chapter_word_count = 0;
    state.save(repo)?;

    // Commit the state update (and chapter file in case it was just created)
    git::run_git(repo, &["add", ".ink-state.yml", &chapter_rel])
        .with_context(|| "Failed to git add for chapter advance")?;
    git::run_git(repo, &["commit", "-m", &format!("chapter: advance to chapter {}", next_chapter)])
        .with_context(|| "Failed to commit chapter advance")?;

    info!("Advanced to chapter {}", next_chapter);

    Ok(serde_json::json!({
        "status": "advanced",
        "new_chapter": next_chapter,
        "chapter_file": chapter_rel,
        "chapter_content": chapter_content,
    }))
}

// ─── status ───────────────────────────────────────────────────────────────────

/// Return a lightweight read-only JSON snapshot of the book's current state.
/// Reads only local files — no git operations, no network.
pub fn book_status(repo: &Path) -> Result<serde_json::Value> {
    let state = InkState::load(repo)?;
    let config = Config::load(repo).ok();

    let book_path = repo.join("Current version").join("Full_Book.md");
    let total_word_count = if book_path.exists() {
        let content = std::fs::read_to_string(&book_path)
            .with_context(|| "Failed to read Full_Book.md")?;
        count_prose_words(&content)
    } else {
        0
    };

    let lock_path = repo.join(".ink-running");
    let lock_age_seconds = crate::context::read_lock_age(repo);
    let complete = repo.join("COMPLETE").exists();
    let initialized = repo.join("Global Material").join("Config.yml").exists();

    let (target_length, words_per_chapter, words_per_session, chapter_close_suggested, completion_ready) =
        match &config {
            Some(c) => (
                c.target_length,
                c.words_per_chapter,
                c.words_per_session,
                state.current_chapter_word_count >= (c.words_per_chapter as f64 * 0.9) as u32,
                total_word_count >= (c.target_length as f64 * 0.9) as u32,
            ),
            None => (0, 0, 0, false, false),
        };

    Ok(serde_json::json!({
        "initialized": initialized,
        "complete": complete,
        "current_chapter": state.current_chapter,
        "current_chapter_word_count": state.current_chapter_word_count,
        "words_per_chapter": words_per_chapter,
        "chapter_close_suggested": chapter_close_suggested,
        "total_word_count": total_word_count,
        "target_length": target_length,
        "words_per_session": words_per_session,
        "completion_ready": completion_ready,
        "session_active": lock_path.exists(),
        "session_age_seconds": lock_age_seconds,
    }))
}

// ─── rollback ─────────────────────────────────────────────────────────────────

/// Revert main (and draft) to the snapshot tag created at the start of the
/// last writing session, undoing all prose generated in that session.
pub fn rollback_session(repo_path: &Path) -> Result<()> {
    // Collect all ink-* tags and sort reverse-chronologically.
    let raw = git::run_git(repo_path, &["tag", "-l", "ink-*"])?;
    let mut tags: Vec<&str> = raw
        .lines()
        .map(|l| l.trim())
        .filter(|l| !l.is_empty())
        .collect();
    tags.sort_by(|a, b| b.cmp(a));

    let target = tags
        .first()
        .ok_or_else(|| anyhow::anyhow!("No ink-* snapshot tags found — nothing to roll back"))?;

    println!("\n  Rollback target : {}", target);
    if let Some(prev) = tags.get(1) {
        println!("  Previous snapshot: {}", prev);
    }
    println!();
    println!("  This will permanently remove the last session's prose,");
    println!("  Summary.md entry, and Changelog entry, then force-push.");

    let confirmed = Confirm::new("Confirm rollback?")
        .with_default(false)
        .prompt()
        .with_context(|| "Failed to read confirmation")?;

    if !confirmed {
        println!("  Rollback cancelled.");
        return Ok(());
    }

    // Ensure we're on main before resetting
    git::run_git(repo_path, &["checkout", "main"])
        .with_context(|| "Failed to checkout main")?;

    // Hard reset main to the snapshot tag
    git::run_git(repo_path, &["reset", "--hard", target])
        .with_context(|| format!("Failed to reset to {}", target))?;

    // Force-push main
    git::run_git(repo_path, &["push", "--force", "origin", "main"])
        .with_context(|| "Failed to force-push main")?;

    // Reset draft to main if it exists
    if git::run_git(repo_path, &["show-ref", "--verify", "refs/heads/draft"]).is_ok() {
        git::run_git(repo_path, &["branch", "-f", "draft", "main"])
            .with_context(|| "Failed to reset draft branch")?;
        git::run_git(repo_path, &["push", "--force", "origin", "draft"])
            .with_context(|| "Failed to force-push draft")?;
    }

    println!("\n  Rolled back to {}.", target);
    println!("  The last session's prose has been removed.");
    println!("  Run the next session normally when ready.\n");

    Ok(())
}

// ─── Tests ────────────────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn count_words_ignores_html_comment_lines() {
        let content = "Hello world\n<!-- PAGE 1 -->\nFoo bar baz";
        assert_eq!(count_prose_words(content), 5);
    }

    #[test]
    fn count_words_empty_input() {
        assert_eq!(count_prose_words(""), 0);
    }

    #[test]
    fn find_instruction_matches_author_comment() {
        let content = "Some prose\n<!-- INK: make this better -->\nMore prose";
        assert!(find_first_ink_instruction(content).is_some());
    }

    #[test]
    fn find_instruction_ignores_engine_new_marker() {
        let content = "<!-- INK:NEW:START -->\nProse\n<!-- INK:NEW:END -->";
        assert!(find_first_ink_instruction(content).is_none());
    }

    #[test]
    fn find_instruction_ignores_engine_reworked_marker() {
        let content = "<!-- INK:REWORKED:START -->\nProse\n<!-- INK:REWORKED:END -->";
        assert!(find_first_ink_instruction(content).is_none());
    }

    #[test]
    fn find_instruction_skips_engine_markers_to_find_author() {
        let content =
            "<!-- INK:NEW:START -->\nProse\n<!-- INK:NEW:END -->\n<!-- INK: fix this -->";
        let pos = find_first_ink_instruction(content).expect("should find author instruction");
        assert!(content[pos..].starts_with("<!-- INK: fix this -->"));
    }

    #[test]
    fn strip_engine_markers_removes_start_end_lines() {
        let content =
            "Before\n<!-- INK:NEW:START -->\nNew prose\n<!-- INK:NEW:END -->\nAfter";
        let stripped = strip_engine_markers(content);
        assert!(!stripped.contains("<!-- INK:NEW:START -->"));
        assert!(!stripped.contains("<!-- INK:NEW:END -->"));
        assert!(stripped.contains("New prose"));
        assert!(stripped.contains("Before"));
        assert!(stripped.contains("After"));
    }

    #[test]
    fn strip_engine_markers_handles_reworked() {
        let content = "A\n<!-- INK:REWORKED:START -->\nB\n<!-- INK:REWORKED:END -->\nC";
        let stripped = strip_engine_markers(content);
        assert!(!stripped.contains("INK:REWORKED"));
        assert!(stripped.contains('B'));
    }

    #[test]
    fn pagination_inserts_marker_at_boundary() {
        // Build a single paragraph of 300 words; with words_per_page=250 and
        // start_word_count=0 there should be a PAGE 2 marker inserted.
        let para = "word ".repeat(300);
        let result = insert_pagination(0, para.trim(), 250);
        assert!(result.contains("<!-- PAGE 2 -->"), "expected PAGE 2 in: {result}");
    }

    #[test]
    fn pagination_disabled_when_words_per_page_is_zero() {
        let content = "Some content here";
        let result = insert_pagination(0, content, 0);
        assert_eq!(result, content);
    }

    #[test]
    fn pagination_respects_existing_word_count() {
        // Already at 240 words; next page boundary is 250. A 20-word paragraph
        // should trigger a marker.
        let para = "word ".repeat(20);
        let result = insert_pagination(240, para.trim(), 250);
        assert!(result.contains("<!-- PAGE 2 -->"), "expected PAGE 2 in: {result}");
    }

    #[test]
    fn session_close_guard_returns_err_without_lock() {
        let tmp = tempfile::tempdir().unwrap();
        let err = close_session(tmp.path(), "prose", None, &[]).unwrap_err();
        assert!(err.to_string().contains("no active session"));
    }

    #[test]
    fn complete_guard_returns_err_when_already_complete() {
        let tmp = tempfile::tempdir().unwrap();
        std::fs::write(tmp.path().join("COMPLETE"), "").unwrap();
        let err = complete_session(tmp.path()).unwrap_err();
        assert!(err.to_string().contains("already complete"));
    }
}
