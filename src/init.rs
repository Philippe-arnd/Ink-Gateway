use anyhow::{Context, Result};
use inquire::{Confirm, Text};
use serde::Serialize;
use std::collections::HashMap;
use std::fs;
use std::path::Path;
use std::process::Command;

const CONFIG_YML: &str = include_str!("../templates/Config.yml");
const SOUL_MD: &str = include_str!("../templates/Soul.md");
const OUTLINE_MD: &str = include_str!("../templates/Outline.md");
const CHARACTERS_MD: &str = include_str!("../templates/Characters.md");
const LORE_MD: &str = include_str!("../templates/Lore.md");
const CHAPTER_01_MD: &str = include_str!("../templates/Chapter_01.md");
const CURRENT_MD: &str = include_str!("../templates/current.md");
const AGENTS_MD: &str = include_str!("../templates/AGENTS.md");

#[derive(Serialize)]
pub struct Question {
    pub question: &'static str,
    pub hint: &'static str,
    pub target_file: &'static str,
}

#[derive(Serialize)]
pub struct InitPayload {
    pub status: &'static str,
    pub title: String,
    pub author: String,
    pub files_created: Vec<String>,
    pub questions: Vec<Question>,
}

fn fill(template: &str, title: &str, author: &str) -> String {
    template
        .replace("{{TITLE}}", title)
        .replace("{{AUTHOR}}", author)
}

pub fn run_init(repo_path: &Path, title: &str, author: &str) -> Result<InitPayload> {
    // Guard: already initialized
    let config_path = repo_path.join("Global Material/Config.yml");
    if config_path.exists() {
        eprintln!(
            "{}",
            serde_json::json!({
                "error": "repository already initialized",
                "status": "error"
            })
        );
        std::process::exit(1);
    }

    let mut files_created: Vec<String> = Vec::new();

    // Create directories
    for dir in &[
        "Global Material",
        "Chapters material",
        "Review",
        "Changelog",
        "Current version",
    ] {
        fs::create_dir_all(repo_path.join(dir))?;
    }

    let write_file = |rel: &str, contents: &str, files: &mut Vec<String>| -> Result<()> {
        let full = repo_path.join(rel);
        fs::write(&full, contents)?;
        files.push(rel.to_string());
        Ok(())
    };

    write_file("Global Material/Config.yml", &fill(CONFIG_YML, title, author), &mut files_created)?;
    write_file("Global Material/Soul.md", &fill(SOUL_MD, title, author), &mut files_created)?;
    write_file("Global Material/Outline.md", &fill(OUTLINE_MD, title, author), &mut files_created)?;
    write_file("Global Material/Characters.md", &fill(CHARACTERS_MD, title, author), &mut files_created)?;
    write_file("Global Material/Lore.md", &fill(LORE_MD, title, author), &mut files_created)?;
    write_file("Global Material/Summary.md", "", &mut files_created)?;
    write_file("Chapters material/Chapter_01.md", &fill(CHAPTER_01_MD, title, author), &mut files_created)?;
    write_file("Review/current.md", &fill(CURRENT_MD, title, author), &mut files_created)?;
    write_file("AGENTS.md", AGENTS_MD, &mut files_created)?;
    write_file("Changelog/.gitkeep", "", &mut files_created)?;
    write_file(
        "Current version/Full_Book.md",
        "<!-- ⚠ INK-GATEWAY:MANAGED — Do not edit this file directly.\n\
         Human edits belong in Review/current.md.\n\
         Validated content is appended automatically after each session.\n\
         Use `ink-cli rollback` to undo the last session. -->\n",
        &mut files_created,
    )?;
    write_file(
        ".ink-state.yml",
        "current_chapter: 1\ncurrent_chapter_word_count: 0\n",
        &mut files_created,
    )?;

    git_commit_and_push(repo_path)?;

    let questions = vec![
        // ── Language ──────────────────────────────────────────────────────────
        Question {
            question: "What language should the engine write in?",
            hint: "e.g. English, French, Spanish, German — use the full language name",
            target_file: "Global Material/Config.yml",
        },
        // ── Voice & Style ──────────────────────────────────────────────────────
        Question {
            question: "What is the genre and overall tone?",
            hint: "e.g. Dark fantasy with literary prose, melancholic and immersive",
            target_file: "Global Material/Soul.md",
        },
        Question {
            question: "What is the narrator perspective and tense?",
            hint: "e.g. Third-person limited, past tense, close to the protagonist",
            target_file: "Global Material/Soul.md",
        },
        // ── Characters ─────────────────────────────────────────────────────────
        Question {
            question: "Who is the protagonist? Give a name and one defining trait.",
            hint: "e.g. Mara, a disgraced soldier haunted by a massacre she survived",
            target_file: "Global Material/Characters.md",
        },
        Question {
            question: "Who or what is the main antagonist or obstacle?",
            hint: "e.g. The Conclave, a religious order that controls all magic",
            target_file: "Global Material/Characters.md",
        },
        // ── Plot Arc ───────────────────────────────────────────────────────────
        Question {
            question: "How does the story open? What kicks it off?",
            hint: "1-2 sentences — the inciting event that sets everything in motion",
            target_file: "Global Material/Outline.md",
        },
        Question {
            question: "What is the midpoint turning point?",
            hint: "1-2 sentences — the moment that changes everything for the protagonist",
            target_file: "Global Material/Outline.md",
        },
        Question {
            question: "How does the story end?",
            hint: "1-2 sentences — the resolution and what the protagonist gains or loses",
            target_file: "Global Material/Outline.md",
        },
        // ── World & Setting ────────────────────────────────────────────────────
        Question {
            question: "Describe the world and setting.",
            hint: "e.g. A crumbling empire on the edge of a magical desert, post-industrial era",
            target_file: "Global Material/Lore.md",
        },
        // ── Chapter 1 ──────────────────────────────────────────────────────────
        Question {
            question: "What happens in Chapter 1? What should the reader feel by the end?",
            hint: "Key scene(s) and the emotional note the chapter closes on",
            target_file: "Chapters material/Chapter_01.md",
        },
    ];

    Ok(InitPayload {
        status: "initialized",
        title: title.to_string(),
        author: author.to_string(),
        files_created,
        questions,
    })
}

// ─── reset ────────────────────────────────────────────────────────────────────

/// Wipe all book content so the repository can be re-initialized with `init`.
/// The user must type the repository directory name to confirm — this is a
/// destructive, irreversible operation.
pub fn run_reset(repo_path: &Path) -> Result<()> {
    let repo_name = repo_path
        .canonicalize()
        .unwrap_or_else(|_| repo_path.to_path_buf())
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("this-repository")
        .to_string();

    println!();
    println!("  ⚠  Reset will permanently delete all book content in «{}».", repo_name);
    println!("  The git history is preserved, but all files will be removed.");
    println!("  You can re-run `ink-cli init` afterwards to start fresh.");
    println!();

    let input = Text::new(&format!("Type «{}» to confirm", repo_name))
        .prompt()
        .with_context(|| "Failed to read confirmation input")?;

    if input.trim() != repo_name {
        println!("\n  Name does not match — reset cancelled.\n");
        return Ok(());
    }

    println!("\n  Removing book content…");

    // Remove all tracked content directories and files in one git rm call.
    // --ignore-unmatch silences errors for files that don't exist.
    let _ = Command::new("git")
        .args([
            "rm", "-rf", "--ignore-unmatch",
            "Global Material/",
            "Chapters material/",
            "Review/",
            "Changelog/",
            "Current version/",
            "AGENTS.md",
            "COMPLETE",
            ".ink-running",
            ".ink-kill",
            ".ink-state.yml",
        ])
        .current_dir(repo_path)
        .status();

    // Re-create .gitkeep placeholders so the directories exist for the next init
    for dir in &["Changelog", "Chapters material", "Review", "Current version"] {
        let dir_path = repo_path.join(dir);
        fs::create_dir_all(&dir_path)?;
        fs::write(dir_path.join(".gitkeep"), "")?;
    }

    let run = |args: &[&str]| -> Result<()> {
        let status = Command::new("git")
            .args(args)
            .current_dir(repo_path)
            .status()?;
        if !status.success() {
            anyhow::bail!("git {} failed", args.join(" "));
        }
        Ok(())
    };

    run(&["add", "-A"])?;
    run(&["commit", "-m", "reset: wipe book content for re-initialization"])?;

    let push = Command::new("git")
        .args(["push", "origin", "main"])
        .current_dir(repo_path)
        .status()?;
    if !push.success() {
        tracing::warn!("git push skipped — no remote configured");
    }

    println!("\n  Reset complete.");
    println!("  Run `ink-cli init <repo-path> --title \"...\" --author \"...\"` to start fresh.\n");

    Ok(())
}

fn git_commit_and_push(repo_path: &Path) -> Result<()> {
    let run = |args: &[&str]| -> Result<()> {
        let status = Command::new("git")
            .args(args)
            .current_dir(repo_path)
            .status()?;
        if !status.success() {
            anyhow::bail!("git {} failed with status {}", args.join(" "), status);
        }
        Ok(())
    };

    run(&["add", "-A"])?;
    run(&["commit", "-m", "init: scaffold book repository"])?;

    // Push is best-effort: skip if no remote is configured (common in local smoke tests)
    let push_status = Command::new("git")
        .args(["push", "origin", "main"])
        .current_dir(repo_path)
        .status()?;

    if !push_status.success() {
        tracing::warn!("git push origin main failed — no remote configured or push rejected; skipping");
    }

    Ok(())
}

// ─── Interactive Q&A (TTY mode) ───────────────────────────────────────────────

/// Run when `init` is called from a real terminal. Asks 10 focused questions
/// using inline prompts, shows a summary, and commits on confirmation.
pub fn run_interactive_qa(repo_path: &Path, payload: &InitPayload) -> Result<()> {
    // (start_index, section_label)
    let sections: &[(usize, &str)] = &[
        (0, "Language"),
        (1, "Voice & Style"),
        (3, "Characters"),
        (5, "Plot Arc"),
        (8, "World & Setting"),
        (9, "Chapter 1"),
    ];

    println!();
    println!("  Ink Gateway — Book Setup");
    println!("  «{}» by {}", payload.title, payload.author);
    println!("  10 questions — about 5 minutes.");
    println!();

    let mut answers: Vec<(usize, String)> = Vec::new();

    for (i, q) in payload.questions.iter().enumerate() {
        // Print section header when a new section begins
        if let Some((_, name)) = sections.iter().find(|(start, _)| *start == i) {
            if i > 0 {
                println!();
            }
            println!("  ── {} {}", name, "─".repeat(48_usize.saturating_sub(name.len())));
        }

        let answer = match Text::new(q.question)
            .with_help_message(q.hint)
            .prompt()
        {
            Ok(a) => a,
            Err(inquire::InquireError::OperationCanceled)
            | Err(inquire::InquireError::OperationInterrupted) => {
                println!("\n  Setup cancelled. No files were changed.");
                return Ok(());
            }
            Err(e) => anyhow::bail!("Input error on question {}: {}", i + 1, e),
        };

        answers.push((i, answer));
    }

    // Summary review
    println!();
    println!("  ── Review ───────────────────────────────────────────────────────");
    for (i, answer) in &answers {
        let q = &payload.questions[*i];
        let display = if answer.trim().is_empty() { "(skipped)" } else { answer.trim() };
        println!("  {}. {}:", i + 1, q.question);
        println!("     {}", display);
    }
    println!();

    let confirmed = match Confirm::new("Commit these answers and prepare the book?")
        .with_default(true)
        .prompt()
    {
        Ok(b) => b,
        Err(inquire::InquireError::OperationCanceled)
        | Err(inquire::InquireError::OperationInterrupted) => {
            println!("\n  Cancelled. No files were changed.");
            return Ok(());
        }
        Err(e) => anyhow::bail!("Confirmation error: {}", e),
    };

    if !confirmed {
        println!("\n  Cancelled. Run init again to start over.");
        return Ok(());
    }

    write_answers_to_files(repo_path, &answers)?;
    commit_qa_answers(repo_path)?;

    println!();
    println!("  Book is ready.");
    println!("  Review Global Material/ in your editor, then start the first writing session.");
    println!();

    Ok(())
}

/// Aggregate answers (by question index) and write them as structured markdown
/// to their respective target files. Multiple answers targeting the same file
/// are combined under section headings.
fn write_answers_to_files(repo_path: &Path, answers: &[(usize, String)]) -> Result<()> {
    let map: HashMap<usize, &str> = answers
        .iter()
        .map(|(i, a)| (*i, a.as_str()))
        .collect();

    // Config.yml — update `language:` field only (q0)
    if let Some(&lang) = map.get(&0) {
        let path = repo_path.join("Global Material/Config.yml");
        let content = fs::read_to_string(&path)
            .with_context(|| "Failed to read Config.yml")?;
        let updated = content
            .lines()
            .map(|line| {
                if line.starts_with("language:") {
                    format!("language: {}", lang.trim())
                } else {
                    line.to_string()
                }
            })
            .collect::<Vec<_>>()
            .join("\n");
        fs::write(&path, format!("{}\n", updated))
            .with_context(|| "Failed to write Config.yml")?;
    }

    // Soul.md — genre/tone (q1) + narrator/perspective (q2)
    {
        let genre = map.get(&1).copied().unwrap_or("").trim().to_string();
        let narrator = map.get(&2).copied().unwrap_or("").trim().to_string();
        if !genre.is_empty() || !narrator.is_empty() {
            let mut content = String::from("# Soul\n");
            if !genre.is_empty() {
                content.push_str("\n## Genre & Tone\n\n");
                content.push_str(&genre);
                content.push('\n');
            }
            if !narrator.is_empty() {
                content.push_str("\n## Narrator & Perspective\n\n");
                content.push_str(&narrator);
                content.push('\n');
            }
            fs::write(repo_path.join("Global Material/Soul.md"), content)
                .with_context(|| "Failed to write Soul.md")?;
        }
    }

    // Characters.md — protagonist (q3) + antagonist (q4)
    {
        let protag = map.get(&3).copied().unwrap_or("").trim().to_string();
        let antag = map.get(&4).copied().unwrap_or("").trim().to_string();
        if !protag.is_empty() || !antag.is_empty() {
            let mut content = String::from("# Characters\n");
            if !protag.is_empty() {
                content.push_str("\n## Protagonist\n\n");
                content.push_str(&protag);
                content.push('\n');
            }
            if !antag.is_empty() {
                content.push_str("\n## Antagonist / Obstacle\n\n");
                content.push_str(&antag);
                content.push('\n');
            }
            fs::write(repo_path.join("Global Material/Characters.md"), content)
                .with_context(|| "Failed to write Characters.md")?;
        }
    }

    // Outline.md — opening (q5) + midpoint (q6) + ending (q7)
    {
        let opening = map.get(&5).copied().unwrap_or("").trim().to_string();
        let midpoint = map.get(&6).copied().unwrap_or("").trim().to_string();
        let ending = map.get(&7).copied().unwrap_or("").trim().to_string();
        if !opening.is_empty() || !midpoint.is_empty() || !ending.is_empty() {
            let mut content = String::from("# Outline\n");
            if !opening.is_empty() {
                content.push_str("\n## Opening\n\n");
                content.push_str(&opening);
                content.push('\n');
            }
            if !midpoint.is_empty() {
                content.push_str("\n## Midpoint\n\n");
                content.push_str(&midpoint);
                content.push('\n');
            }
            if !ending.is_empty() {
                content.push_str("\n## Ending\n\n");
                content.push_str(&ending);
                content.push('\n');
            }
            fs::write(repo_path.join("Global Material/Outline.md"), content)
                .with_context(|| "Failed to write Outline.md")?;
        }
    }

    // Lore.md — world/setting (q8)
    if let Some(&setting) = map.get(&8) {
        let setting = setting.trim();
        if !setting.is_empty() {
            let content = format!("# Lore\n\n## Setting\n\n{}\n", setting);
            fs::write(repo_path.join("Global Material/Lore.md"), content)
                .with_context(|| "Failed to write Lore.md")?;
        }
    }

    // Chapter_01.md — beats (q9)
    if let Some(&beats) = map.get(&9) {
        let beats = beats.trim();
        if !beats.is_empty() {
            let content = format!("# Chapter 1\n\n## Beats\n\n{}\n", beats);
            fs::write(repo_path.join("Chapters material/Chapter_01.md"), content)
                .with_context(|| "Failed to write Chapter_01.md")?;
        }
    }

    Ok(())
}

fn commit_qa_answers(repo_path: &Path) -> Result<()> {
    let run = |args: &[&str]| -> Result<()> {
        let status = Command::new("git")
            .args(args)
            .current_dir(repo_path)
            .status()?;
        if !status.success() {
            anyhow::bail!("git {} failed", args.join(" "));
        }
        Ok(())
    };

    run(&["add", "-A"])?;
    run(&["commit", "-m", "init: populate global material from author Q&A"])?;

    let push = Command::new("git")
        .args(["push", "origin", "main"])
        .current_dir(repo_path)
        .status()?;
    if !push.success() {
        tracing::warn!("git push skipped — no remote configured");
    }

    Ok(())
}
